from scene import Scene
# from scene_custom import Scene
import taichi as ti
from taichi.math import *

exposure = 30
scene = Scene(voxel_edges=2, exposure=exposure)
# scene.set_floor(-0.05, (1.0, 1.0, 1.0))
# scene.set_background_color((1.0, 0, 0))
scene.set_directional_light((1, 1, 1), 0.1, vec3(1, 1, 1) / exposure)
scene.set_background_color(vec3(0.3, 0.4, 0.6) / exposure)

n = 64

@ti.func
def draw_base():
    # for I in ti.grouped(ti.ndrange((0, n), (0, 1), (0, n))):
    #     scene.set_voxel(I, 2, )
    for i, j in ti.ndrange(n, n):
        c = vec3(180.0, 180.0, 192.0) / 255.0
        if min(i, j) == 0 or max(i, j) == n - 1:
            scene.set_voxel(vec3(i, 0, j), 2, c)
            scene.set_voxel(vec3(-i, 0, j), 2, c)
            scene.set_voxel(vec3(i, 0, -j), 2, c)
            scene.set_voxel(vec3(-i, 0, -j), 2, c)
        else:
            scene.set_voxel(vec3(i, 0, j), 1, c)
            scene.set_voxel(vec3(-i, 0, j), 1, c)
            scene.set_voxel(vec3(i, 0, -j), 1, c)
            scene.set_voxel(vec3(-i, 0, -j), 1, c)

@ti.func
def draw_pole(pos, h):
    i, j = int(n * pos[0]), int(n * pos[1])
    for k in range(h):
        scene.set_voxel(vec3(i, k, j), 1, vec3(119.0, 123.0, 106.0) / 255.0)

@ti.func
def p_to_x(p):
    return p * 2.0 * n

@ti.func
def x_to_p(x):
    return x / 2.0 / n

@ti.func
def x_to_I(x):
    return int(x) # is this good for negative floats?

@ti.func
def I_to_x(I):
    return I + 0.5

@ti.func
def interp_line(I1, I2, i, J1, J2):  # integers
    yj = I_to_x(J1) + float(J2 - J1) * (i - I1) / (I2 - I1)
    return x_to_I(yj)

@ti.func
def draw_ipar_rectangle(ps, h, c):
    H = x_to_I(p_to_x(h))

    IJKs = [x_to_I(p_to_x(p)) for p in ps]
    print('IJKs')
    print(IJKs)
    I1 = IJKs[0][0]
    I2 = IJKs[2][0]
    for i in ti.ndrange((I1, I2+1),):
        z1 = interp_line(I1, I2, i, IJKs[0][2], IJKs[2][2])
        z2 = interp_line(I1, I2, i, IJKs[1][2], IJKs[3][2])
        k1 = x_to_I(z1)
        k2 = x_to_I(z2)

        print(i, IJKs[0][2], IJKs[2][2], z1, k1)
        print(i, IJKs[1][2], IJKs[3][2], z2, k2)
        for k in ti.ndrange((k1, k2+1),):
            scene.set_voxel(vec3(i, H, k), 2, c)

@ti.func
def draw_roof(scale):
    c = vec3(225.0, 225.0, 225.0) / 255.0
    verts = [
        vec3(-0.5, 0.4, -0.6),
        vec3( 0.0, 0.4, -0.8),
        vec3( 0.5, 0.4, -0.6),

        vec3(-0.5, 0.4, 0.6),
        vec3( 0.0, 0.4, 0.4),
        vec3( 0.5, 0.4, 0.6),
    ]
    h = 0.4
    vs = [v * scale for v in verts]
    print(vs)
    draw_ipar_rectangle([vs[0], vs[3], vs[1], vs[4]], h, c)
    draw_ipar_rectangle([vs[1], vs[4], vs[2], vs[5]], h, c)


@ti.kernel
def initialize_voxels():
    draw_base()

    draw_pole((0.4, 0.6), 50)
    draw_pole((-0.4, 0.6), 50)
    draw_pole((0.4, -0.6), 50)
    draw_pole((-0.4, -0.6), 50)

    print('hey')

    draw_roof(0.5)


initialize_voxels()

ti.sync()

scene.finish()
